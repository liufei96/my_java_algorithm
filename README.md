https://www.jianshu.com/u/eb13e0cfeef6
# 什么是算法？
算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。
也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。
不同的算法可能用不同的时间、空间或效率来完成同样的任务。一个算法的优劣可以用**空间复杂度**与**时间复杂度**来衡量。（来自百度百科）

作为一名Java web开发工程师，平时写的算法并不是很多，但是这并不能说明算法不重要。学习算法，写出高效率的程序，这样我们才能比别人更优秀，
所以现在就开始刷题吧。

# 算法的时间复杂度
### 时间频度
一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，
哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。
一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。

### 时间复杂度
前面提到的时间频度T(n)中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律，为此我们引入时间复杂度的概念。
一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，
T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数，记作T(n)=O(f(n))，它称为算法的渐进时间复杂度，简称时间复杂度。

### 大O表示法
算法的时间复杂度，我们一般使用大O法表示。
大O表示法O(f(n))中的f(n)的值可以为1、n、logn、n²等，因此我们可以将O(1)、O(n)、O(logn)、O(n²)分别可以称为常数阶、线性阶、对数阶和平方阶，
那么如何推导出f(n)的值呢？我们接着来看推导大O阶的方法。

### 推导大O阶
推导大O阶，我们可以按照如下的规则来进行推导，得到的结果就是大O表示法：
1.用常数1来取代运行时间中所有加法常数。
2.修改后的运行次数函数中，只保留最高阶项
3.如果最高阶项存在且不是1，则去除与这个项相乘的常数。

#### 常数阶
先举了例子，如下所示。
```java
  int sum = 0,n = 2;  //执行一次  
  sum = (1+n) * n;  //执行一次  
  System.out.println (sum); //执行一次 
```
上面算法的运行的次数的函数为f(n)=3，根据推导大O阶的规则1，我们需要将常数3改为1，则这个算法的时间复杂度为O(1)。
因为sum = (1+n) * n的执行次数与大小n并没有关系，所以这个算法的时间复杂度仍旧是O(1)，我们可以称之为常数阶。

#### 线性阶
线性阶主要要分析循环结构的运行情况，如下所示。
```java
 for (int i = 0,i < n;i++) {
  // 时间复杂度为O(1)的算法
  ...
 }
```
上面算法循环体中的代码执行了n次，因此时间复杂度为O(n)。

#### 对数阶
```java
  int number = 1;
  while(number < n) {
    number = number * 2;
    //时间复杂度为O(1)的算法
  }
```
可以看出上面的代码，随着number每次乘以2后，都会越来越接近n，当number不小于n时就会退出循环。
假设循环的次数为X，则由2^x=n得出x=log₂n，因此得出这个算法的时间复杂度为O(logn)。

#### 平方阶
平方阶，也就是我们所说的循环嵌套。
```java
 for(int i=0;i<n;i++){   
      for(int j=0;j<n;j++){
         //复杂度为O(1)的算法
         ... 
      }
  }
```
内层循环的时间复杂度在讲到线性阶时就已经得知是O(n)，现在经过外层循环n次，那么这段算法的时间复杂度则为O(n²)。 

接下来我们来算一下下面算法的时间复杂度：
```java
for(int i=0;i<n;i++){   
      for(int j=i;j<n;j++){
         //复杂度为O(1)的算法
         ... 
      }
  }
```
需要注意的是内循环中int j=i，而不是int j=0。

当i=0时，内层循环执行了n次
当i=1时，内存循环执行了n-1次
......
当i=n-1时，内存循环执行了1次

所以总次数就是：
n + (n-1) + (n-2) + ... + 1 
= (n + 1)n / 2
= n²/2+n/2

根据此前讲过的推导大O阶的规则的第二条：只保留最高阶，因此保留n²/2。根据第三条去掉和这个项的常数，则去掉1/2,最终这段代码的时间复杂度为O(n²)。

#### nlogn阶
f(n)=nlogn时，时间复杂度为O(nlogn)
```java
 int number = 1;
  while(number < nⁿ) {
    number = number * 2;
    //时间复杂度为O(1)的算法
  }
```
2 ^ x = nⁿ，则 x=nlogn

#### 立方阶
f(n)=n³时，时间复杂度为O(n³)。这就是三层循环
```java
  for(int i = 0;i < n;i++ ) {
    for (int j = 0;j < n;j++) {
        for (int k = 0;k < n;k++) {
        ...
        //时间复杂度为O(1)的算法
        }
    }
  }
```
经过三层循环，时间复杂度为O(n³)

#### 指数阶
f(n)=2ⁿ时，时间复杂度为O(2ⁿ)
```java
 for (int i = 0, i < 2ⁿ； i++) {
 }
```

#### 阶乘阶
f(n)=n!时，时间复杂度为O(n!)

#### 平方根阶
f(n)=(√n时，时间复杂度为O(√n)

### 复杂度的比较
下面将算法中常见的f(n)值根据几种典型的数量级来列成一张表，根据这种表，我们来看看各种算法复杂度的差异。

n     | logn | √n  | nlogn | n² | 2ⁿ |  n!
-------- | ----- | ----- | ----- | ----- | -----  | ---
5  | 2   | 2 | 10      |  25   | 32   | 120
10  | 2  | 3 | 20   |  100  | 1024  | 3628800
50  | 5  | 7 | 350  |  250  | 约10^15 | 约3.0*10^64
100  | 6  | 10 | 600  |  10000  | 约10^30 | 约9.3*10^157
1000  | 9  | 31 | 9000  |  1000 000  | 约10^300  | 约4.0*10^2567

从上表可以看出，O(n)、O(logn)、O(√n )、O(nlogn )随着n的增加，复杂度提升不大，因此这些复杂度属于效率高的算法，
反观O(2ⁿ)和O(n!)当n增加到50时，复杂度就突破十位数了，这种效率极差的复杂度最好不要出现在程序中，
因此在动手编程时要评估所写算法的最坏情况的复杂度。

常用的时间复杂度按照耗费的时间从小到大依次是：

> O(1)<O(logn)<O(n)<O(nlogn)<O(n²)<O(n³)<O(2ⁿ)<O(n!)

# 算法的空间复杂度
一个算法的空间复杂度，一般是指执行这个算法所需的存储空间。
一个算法所占用的存储空间包括算法程序所占用的空间、输入的初始数据所占用的存储空间及算法执行过程中所需要的额外空间。








